import { WindowBase } from '../window-base.js';
import { VulnerabilityScanner } from './vulnerability-scanner-functions/vulnerability-scanner.js';
import { webTargetRegistry } from './vulnerability-scanner-functions/web-target-registry.js';
import { VulnerabilityScannerUI } from './vulnerability-scanner-functions/vulnerability-scanner-ui.js';
import { VulnerabilityReportGenerator } from './vulnerability-scanner-functions/vulnerability-report-generator.js';

export class VulnerabilityScannerApp extends WindowBase {
    constructor() {
        super('vulnerability-scanner', 'Web Vulnerability Scanner', {
            width: '85%',
            height: '80%',
            x: 100,
            y: 50
        });
        
        this.scanner = new VulnerabilityScanner();
        this.targetRegistry = webTargetRegistry;
        this.reportGenerator = new VulnerabilityReportGenerator();
        this.ui = null;
        this.currentScan = null;
        this.isScanning = false;
        this.nmapData = null; // Store nmap scan results for integration
        
        // Initialize Level 4 Dilemma Manager for ethical scenarios
        this.level4DilemmaManager = null;
        this.initializeLevel4Features();
    }

    async initializeLevel4Features() {
        // Check if we're in Level 4 to enable ethical dilemma features
        const level4Started = localStorage.getItem('cyberquest_level_4_started');
        const level4Completed = localStorage.getItem('cyberquest_level_4_completed');
        const currentLevel = window.currentSimulation?.level?.id || 
                           parseInt(localStorage.getItem('cyberquest_current_level')) || 0;
        
        if ((level4Started && !level4Completed) || currentLevel === 4) {
            try {
                // Dynamically import Level4DilemmaManager for level 4
                const module = await import('../../levels/level-four/dialogues/level4-dilemma-manager.js');
                const { Level4DilemmaManager } = module;
                this.level4DilemmaManager = new Level4DilemmaManager(this.desktop || window.desktop);
                console.log('[VulnerabilityScanner] Level 4 ethical dilemma system initialized');
            } catch (error) {
                console.warn('[VulnerabilityScanner] Could not load Level 4 dilemma manager:', error);
                // Continue without level 4 features
            }
        }
    }

    createContent() {
        return `<div id="vulnerability-scanner-container" class="h-full w-full"></div>`;
    }

    initialize() {
        super.initialize();
        
        // Get the content element from the window
        const contentElement = this.windowElement?.querySelector('.window-content');
        if (contentElement) {
            const container = contentElement.querySelector('#vulnerability-scanner-container');
            if (container) {
                // Store reference to this app instance for report generation
                container._vulnerabilityApp = this;
                
                this.ui = new VulnerabilityScannerUI(container, this.scanner, this.targetRegistry, this);
                this.loadDefaultTargets();
            } else {
                console.error('Could not find vulnerability scanner container');
            }
        } else {
            console.error('Could not find window content element for vulnerability scanner');
        }
    }

    bindEvents() {
        // The UI component handles all event binding
        // This method is here for any app-level events if needed
    }

    loadDefaultTargets() {
        // The target registry is already initialized with municipality targets
        // Just refresh the UI if it exists
        if (this.ui) {
            this.ui.refresh();
        }
    }

    async startVulnerabilityScan(selectedTarget, scanOptions) {
        // This method is now handled by the UI component
        // Kept for backward compatibility
        if (this.ui) {
            return this.ui.startScan();
        }
    }

    stopScan() {
        // This method is now handled by the UI component
        // Kept for backward compatibility
        if (this.ui) {
            this.ui.stopScan();
        }
    }

    exportResults() {
        // This method is now handled by the UI component
        // Kept for backward compatibility
        if (this.ui) {
            this.ui.exportResults();
        }
    }

    /**
     * Generate comprehensive vulnerability report
     * @param {string} format - Report format (html, pdf, json, csv)
     * @param {Object} options - Report options
     */
    generateVulnerabilityReport(format = 'html', options = {}) {
        // Check if we have scan results or nmap data
        const currentScan = this.currentScan || this.ui?.scannerLogic?.currentScan;
        const hasNmapData = this.nmapData !== null;
        
        if (!currentScan && !hasNmapData) {
            this.showNotification('No scan results or nmap data available for report generation', 'warning');
            return;
        }

        try {
            // Collect comprehensive scan data
            const scanData = this.collectScanData();
            
            // Generate the report
            const reportData = this.reportGenerator.generateReport(scanData, {
                title: `Vulnerability Assessment Report - ${scanData.target}`,
                analyst: options.analyst || 'CyberQuest Security Team',
                classification: options.classification || 'Internal Use',
                framework: options.framework || 'comprehensive',
                includeNmapData: this.nmapData !== null,
                ...options
            });

            // Export in specified format
            const exportResult = this.reportGenerator.exportReport(reportData, format);
            
            this.showNotification(
                `${format.toUpperCase()} report generated successfully: ${exportResult.filename}`, 
                'success'
            );

            // Trigger Level 4 ethical dilemmas if active
            if (this.level4DilemmaManager) {
                this.level4DilemmaManager.onReportGenerated();
            }

            return exportResult;
        } catch (error) {
            console.error('Report generation failed:', error);
            this.showNotification(`Report generation failed: ${error.message}`, 'error');
            return null;
        }
    }

    /**
     * Collect comprehensive scan data for reporting
     */
    collectScanData() {
        const currentScan = this.currentScan || this.ui?.scannerLogic?.currentScan;
        const targetId = this.ui?.uiRenderer?.elements?.targetSelect?.value;
        const target = targetId ? this.targetRegistry.getTarget(targetId) : null;

        // Base scan data
        const scanData = {
            timestamp: new Date().toISOString(),
            target: target?.name || target?.url || (this.nmapData ? 'Network Scan Target' : 'Unknown Target'),
            targetDetails: target,
            vulnerabilities: currentScan ? currentScan.getVulnerabilities() : [],
            requests: currentScan ? currentScan.getRequests() : [],
            evidence: currentScan ? currentScan.getEvidence() : [],
            summary: currentScan ? currentScan.getSummary() : { total: 0, severityCounts: {} },
            scanConfiguration: this.getScanConfiguration(),
            scanDuration: currentScan ? (currentScan.getDuration ? currentScan.getDuration() : 0) : 0
        };

        // Integrate nmap data if available
        if (this.nmapData) {
            scanData.networkScan = this.nmapData;
            scanData.portInformation = this.extractPortInformation(this.nmapData);
            scanData.serviceFingerprints = this.extractServiceInformation(this.nmapData);
            
            // If no target was found but we have nmap data, use nmap target info
            if (!target && this.nmapData.results) {
                const nmapParsed = this.parseNmapResults(this.nmapData.results);
                if (nmapParsed.vulnerabilities.length > 0) {
                    scanData.vulnerabilities = scanData.vulnerabilities.concat(nmapParsed.vulnerabilities);
                }
                if (nmapParsed.hostInfo) {
                    scanData.target = nmapParsed.hostInfo.hostname || nmapParsed.hostInfo.ip || scanData.target;
                }
            }
        }

        // Add target registry information
        if (target) {
            scanData.targetVulnerabilities = target.vulnerabilities || [];
            scanData.targetRiskLevel = target.getRiskLevel ? target.getRiskLevel() : 'Unknown';
        }

        return scanData;
    }

    /**
     * Integrate nmap scan results
     * @param {Object} nmapResults - Results from nmap command execution
     */
    integrateNmapResults(nmapResults) {
        this.nmapData = {
            timestamp: new Date().toISOString(),
            results: nmapResults,
            source: 'nmap-command'
        };

        // Parse nmap results for port and service information
        const parsedData = this.parseNmapResults(nmapResults);
        
        if (parsedData.vulnerabilities.length > 0) {
            // Add nmap-discovered vulnerabilities to the current target
            const targetId = this.ui?.uiRenderer?.elements?.targetSelect?.value;
            if (targetId) {
                const target = this.targetRegistry.getTarget(targetId);
                if (target) {
                    parsedData.vulnerabilities.forEach(vuln => {
                        this.targetRegistry.addVulnerabilityToTarget(targetId, {
                            ...vuln,
                            source: 'nmap',
                            discoveredAt: new Date().toISOString()
                        });
                    });
                    
                    // Update UI to reflect new vulnerabilities
                    if (this.ui) {
                        this.ui.dataManager.updateStatistics();
                        this.ui.dataManager.updateTargetsList();
                    }
                }
            }
        }

        this.showNotification(
            `Nmap results integrated: ${parsedData.ports.length} ports, ${parsedData.vulnerabilities.length} vulnerabilities`, 
            'success'
        );

        // Update UI button states
        if (this.ui && this.ui.uiRenderer && this.ui.uiRenderer.updateReportButtonsAvailability) {
            this.ui.uiRenderer.updateReportButtonsAvailability();
        }

        // Trigger Level 4 ethical dilemmas if active
        if (this.level4DilemmaManager) {
            this.level4DilemmaManager.onNmapIntegration();
        }

        return parsedData;
    }

    /**
     * Parse nmap results to extract vulnerability information
     */
    parseNmapResults(nmapResults) {
        const parsed = {
            ports: [],
            services: [],
            vulnerabilities: [],
            hostInfo: {}
        };

        // This is a simplified parser - in practice, you'd want more sophisticated parsing
        if (nmapResults && typeof nmapResults === 'string') {
            const lines = nmapResults.split('\n');
            
            lines.forEach(line => {
                // Parse host information
                const hostMatch = line.match(/Nmap scan report for (.+?)(\s+\((.+)\))?/);
                if (hostMatch) {
                    parsed.hostInfo = {
                        hostname: hostMatch[1],
                        ip: hostMatch[3] || hostMatch[1]
                    };
                }
                
                // Parse port information
                if (line.includes('/tcp') || line.includes('/udp')) {
                    const portMatch = line.match(/(\d+)\/(tcp|udp)\s+(\w+)\s+(.+)/);
                    if (portMatch) {
                        parsed.ports.push({
                            port: parseInt(portMatch[1]),
                            protocol: portMatch[2],
                            state: portMatch[3],
                            service: portMatch[4]
                        });
                    }
                }

                // Parse vulnerability script results
                if (line.includes('CVE-') || line.includes('CRITICAL') || line.includes('HIGH')) {
                    parsed.vulnerabilities.push({
                        id: `nmap-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                        title: line.trim(),
                        description: `Vulnerability identified through nmap script scan: ${line.trim()}`,
                        severity: this.extractSeverityFromNmapLine(line),
                        category: 'Network Security',
                        source: 'nmap',
                        evidence: [line.trim()]
                    });
                }

                // Parse service information
                if (line.includes('Service Info:') || line.includes('Version:')) {
                    parsed.services.push(line.trim());
                }
            });
        }

        return parsed;
    }

    /**
     * Extract severity from nmap output line
     */
    extractSeverityFromNmapLine(line) {
        const upperLine = line.toUpperCase();
        if (upperLine.includes('CRITICAL')) return 'critical';
        if (upperLine.includes('HIGH')) return 'high';
        if (upperLine.includes('MEDIUM')) return 'medium';
        if (upperLine.includes('LOW')) return 'low';
        if (upperLine.includes('CVE-')) return 'medium'; // Default CVE to medium
        return 'info';
    }

    /**
     * Extract port information from nmap data
     */
    extractPortInformation(nmapData) {
        if (!nmapData || !nmapData.results) return [];
        
        // Parse port information from nmap results
        return this.parseNmapResults(nmapData.results).ports;
    }

    /**
     * Extract service information from nmap data
     */
    extractServiceInformation(nmapData) {
        if (!nmapData || !nmapData.results) return [];
        
        // Parse service information from nmap results
        return this.parseNmapResults(nmapData.results).services;
    }

    /**
     * Get current scan configuration
     */
    getScanConfiguration() {
        if (!this.ui || !this.ui.uiRenderer || !this.ui.uiRenderer.elements) {
            return { scanType: 'unknown' };
        }

        const elements = this.ui.uiRenderer.elements;
        return {
            scanType: elements.scanTypeSelect?.value || 'unknown',
            options: {
                sqlInjection: elements.scanOptions?.sqlInjection?.checked || false,
                xss: elements.scanOptions?.xss?.checked || false,
                directoryTraversal: elements.scanOptions?.directoryTraversal?.checked || false,
                authenticationBypass: elements.scanOptions?.authenticationBypass?.checked || false,
                csrf: elements.scanOptions?.csrf?.checked || false
            }
        };
    }

    /**
     * Generate multiple report formats simultaneously
     */
    generateAllReports(options = {}) {
        const formats = ['html', 'json', 'csv'];
        const results = [];

        formats.forEach(format => {
            const result = this.generateVulnerabilityReport(format, options);
            if (result) {
                results.push(result);
            }
        });

        if (results.length > 0) {
            this.showNotification(`Generated ${results.length} report formats successfully`, 'success');
        }

        return results;
    }

    /**
     * Export current nmap data
     */
    exportNmapData() {
        if (!this.nmapData) {
            this.showNotification('No nmap data available to export', 'warning');
            return;
        }

        const exportData = {
            timestamp: new Date().toISOString(),
            nmapData: this.nmapData,
            parsedResults: this.parseNmapResults(this.nmapData.results),
            integratedWith: 'vulnerability-scanner'
        };

        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `nmap_integration_data_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);

        this.showNotification('Nmap data exported successfully', 'success');
    }

    /**
     * Manual trigger for Level 4 ethical dilemmas (for testing)
     */
    triggerLevel4Dilemma(dilemmaType) {
        if (!this.level4DilemmaManager) {
            console.warn('[VulnerabilityScanner] Level 4 dilemma manager not active');
            return;
        }
        
        this.level4DilemmaManager.triggerDialogue(dilemmaType);
    }

    /**
     * Get Level 4 progress summary (for debugging)
     */
    getLevel4Progress() {
        if (!this.level4DilemmaManager) {
            return { active: false };
        }
        
        return {
            active: true,
            ethicsScore: this.level4DilemmaManager.getCurrentEthicsScore(),
            choices: this.level4DilemmaManager.getChoicesSummary(),
            completed: this.level4DilemmaManager.isLevel4Complete()
        };
    }

    /**
     * Reset Level 4 progress (for testing)
     */
    resetLevel4Progress() {
        if (this.level4DilemmaManager) {
            this.level4DilemmaManager.resetLevel4Progress();
            this.showNotification('Level 4 progress reset', 'info');
        } else {
            console.warn('[VulnerabilityScanner] Level 4 dilemma manager not active');
        }
    }

    showNotification(message, type = 'info') {
        // This method is now handled by the UI component
        // Kept for backward compatibility
        if (this.ui) {
            this.ui.showNotification(message, type);
        } else {
            // Fallback notification
            const notification = document.createElement('div');
            notification.className = `fixed top-4 right-4 px-4 py-2 rounded-lg text-white text-sm z-50 ${
                type === 'success' ? 'bg-green-600' : 
                type === 'error' ? 'bg-red-600' : 
                type === 'warning' ? 'bg-yellow-600' : 'bg-blue-600'
            }`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }
    }
}
