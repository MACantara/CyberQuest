export class MalwareScannerActions {
    constructor(scanEngine, quarantineManager, activityEmitter = null) {
        this.scanEngine = scanEngine;
        this.quarantineManager = quarantineManager;
        this.activityEmitter = activityEmitter;
    }

    quarantineThreat(threatId) {
        try {
            const scanResults = this.scanEngine.getScanResults();
            const threat = scanResults.find(t => t.id === threatId);
            
            if (!threat) {
                return {
                    success: false,
                    message: 'Threat not found'
                };
            }

            // Move threat to quarantine
            this.quarantineManager.quarantineThreat(threat);
            
            // Remove from scan results
            const index = scanResults.findIndex(t => t.id === threatId);
            if (index !== -1) {
                scanResults.splice(index, 1);
            }
            
            // Emit quarantine activity
            if (this.activityEmitter) {
                this.activityEmitter.emitThreatQuarantined(threat);
            }
            
            return {
                success: true,
                message: `${threat.name} quarantined successfully`
            };
        } catch (error) {
            console.error('Error quarantining threat:', error);
            return {
                success: false,
                message: 'Failed to quarantine threat'
            };
        }
    }

    deleteThreat(threatId) {
        try {
            const scanResults = this.scanEngine.getScanResults();
            const threat = scanResults.find(t => t.id === threatId);
            
            if (!threat) {
                return {
                    success: false,
                    message: 'Threat not found'
                };
            }

            // Confirm deletion
            const confirmed = confirm(`Are you sure you want to permanently delete ${threat.name}?`);
            if (!confirmed) {
                return {
                    success: false,
                    message: 'Deletion cancelled by user'
                };
            }

            // Remove from scan results
            const index = scanResults.findIndex(t => t.id === threatId);
            if (index !== -1) {
                scanResults.splice(index, 1);
            }
            
            // Track deleted threats
            const deletedCount = parseInt(sessionStorage.getItem('malware_scan_deleted_threats') || '0');
            sessionStorage.setItem('malware_scan_deleted_threats', (deletedCount + 1).toString());
            
            // Emit delete activity
            if (this.activityEmitter) {
                this.activityEmitter.emitThreatDeleted(threat);
            }
            
            return {
                success: true,
                message: `${threat.name} deleted successfully`
            };
        } catch (error) {
            console.error('Error deleting threat:', error);
            return {
                success: false,
                message: 'Failed to delete threat'
            };
        }
    }

    restoreThreat(quarantineId) {
        try {
            const restoredThreat = this.quarantineManager.restoreThreat(quarantineId);
            
            if (!restoredThreat) {
                return {
                    success: false,
                    message: 'Threat not found in quarantine'
                };
            }

            // Add back to scan results
            this.scanEngine.getScanResults().push(restoredThreat);
            
            // Emit restore activity
            if (this.activityEmitter) {
                this.activityEmitter.emitThreatRestored(restoredThreat);
            }
            
            return {
                success: true,
                message: `${restoredThreat.name} restored from quarantine`
            };
        } catch (error) {
            console.error('Error restoring threat:', error);
            return {
                success: false,
                message: 'Failed to restore threat'
            };
        }
    }

    deleteFromQuarantine(quarantineId) {
        try {
            const deletedThreat = this.quarantineManager.deleteThreat(quarantineId);
            
            if (!deletedThreat) {
                return {
                    success: false,
                    message: 'Threat not found in quarantine'
                };
            }

            // Emit delete activity
            if (this.activityEmitter) {
                this.activityEmitter.emitThreatDeleted(deletedThreat);
            }
            
            return {
                success: true,
                message: `${deletedThreat.name} permanently deleted from quarantine`
            };
        } catch (error) {
            console.error('Error deleting from quarantine:', error);
            return {
                success: false,
                message: 'Failed to delete from quarantine'
            };
        }
    }

    clearAllQuarantine() {
        try {
            const count = this.quarantineManager.clearQuarantine();
            
            return {
                success: true,
                message: `Cleared ${count} items from quarantine`
            };
        } catch (error) {
            console.error('Error clearing quarantine:', error);
            return {
                success: false,
                message: 'Failed to clear quarantine'
            };
        }
    }

    exportQuarantineReport() {
        try {
            const quarantineItems = this.quarantineManager.getQuarantineItems();
            const stats = this.quarantineManager.getQuarantineStats();
            
            const report = {
                timestamp: new Date().toISOString(),
                totalItems: stats.total,
                itemsByType: stats.byType,
                itemsByRiskLevel: stats.byRiskLevel,
                items: quarantineItems.map(item => ({
                    name: item.name,
                    type: item.type,
                    riskLevel: item.riskLevel,
                    path: item.path,
                    quarantinedAt: item.quarantinedAt,
                    size: item.size
                }))
            };
            
            return {
                success: true,
                data: report,
                message: 'Quarantine report generated successfully'
            };
        } catch (error) {
            console.error('Error generating quarantine report:', error);
            return {
                success: false,
                message: 'Failed to generate quarantine report'
            };
        }
    }

    getDetailedThreatAnalysis(threatId) {
        try {
            const scanResults = this.scanEngine.getScanResults();
            const threat = scanResults.find(t => t.id === threatId);
            
            if (!threat) {
                return {
                    success: false,
                    message: 'Threat not found'
                };
            }

            const analysis = this.scanEngine.getDetailedAnalysis(threat.id);
            
            return {
                success: true,
                data: analysis,
                message: 'Detailed analysis retrieved successfully'
            };
        } catch (error) {
            console.error('Error getting detailed analysis:', error);
            return {
                success: false,
                message: 'Failed to get detailed analysis'
            };
        }
    }

    simulateCleanup() {
        try {
            const scanResults = this.scanEngine.getScanResults();
            const threatsFound = scanResults.length;
            
            if (threatsFound === 0) {
                return {
                    success: true,
                    message: 'No threats found - system is clean'
                };
            }

            // Simulate automatic quarantine of all threats
            const quarantinedThreats = [];
            while (scanResults.length > 0) {
                const threat = scanResults.pop();
                this.quarantineManager.quarantineThreat(threat);
                quarantinedThreats.push(threat);
            }

            // Emit cleanup completion activity
            if (this.activityEmitter) {
                this.activityEmitter.emitMalwareCleanupComplete(quarantinedThreats.length);
            }
            
            return {
                success: true,
                message: `Automatic cleanup completed - ${quarantinedThreats.length} threats quarantined`
            };
        } catch (error) {
            console.error('Error during automatic cleanup:', error);
            return {
                success: false,
                message: 'Automatic cleanup failed'
            };
        }
    }
}
