import { GamingOptimizerRansomware } from './malware/gaming-optimizer-ransomware.js';
import { SteamHelperTrojan } from './malware/steam-helper-trojan.js';
import { PerformanceMonitorSpyware } from './malware/performance-monitor-spyware.js';
import { SystemOptimizerRootkit } from './malware/system-optimizer-rootkit.js';

export class MalwareDatabase {
    constructor() {
        this.malwareDefinitions = new Map();
        this.initializeDatabase();
    }

    initializeDatabase() {
        // Register all known malware
        this.registerMalware('gaming_optimizer_pro.exe', GamingOptimizerRansomware);
        this.registerMalware('steam_helper.exe', SteamHelperTrojan);
        this.registerMalware('performance_monitor.exe', PerformanceMonitorSpyware);
        this.registerMalware('system_optimizer.exe', SystemOptimizerRootkit);
    }

    registerMalware(filename, malwareClass) {
        this.malwareDefinitions.set(filename.toLowerCase(), malwareClass);
    }

    // Check if a file is known malware
    isMaliciousFile(filePath) {
        const filename = filePath.split('\\').pop().toLowerCase();
        return this.malwareDefinitions.has(filename);
    }

    // Create threat result for detected malware
    createThreatResult(filePath) {
        const filename = filePath.split('\\').pop().toLowerCase();
        const MalwareClass = this.malwareDefinitions.get(filename);
        
        if (MalwareClass) {
            const malware = new MalwareClass();
            const threat = malware.toThreatObject();
            threat.path = filePath; // Use actual scanned path
            return threat;
        }
        
        // Fallback for unknown malware
        return {
            id: Math.random().toString(36).substr(2, 9),
            name: filename,
            type: 'Unknown',
            riskLevel: 'Medium',
            size: '1.0 MB',
            path: filePath,
            detected: new Date().toLocaleString()
        };
    }

    // Get all malware types
    getAllMalwareTypes() {
        const types = new Set();
        this.malwareDefinitions.forEach((MalwareClass) => {
            const instance = new MalwareClass();
            types.add(instance.type);
        });
        return Array.from(types);
    }

    // Get malware by type
    getMalwareByType(type) {
        const results = [];
        this.malwareDefinitions.forEach((MalwareClass) => {
            const instance = new MalwareClass();
            if (instance.type.toLowerCase() === type.toLowerCase()) {
                results.push(instance);
            }
        });
        return results;
    }

    // Get malware by risk level
    getMalwareByRiskLevel(riskLevel) {
        const results = [];
        this.malwareDefinitions.forEach((MalwareClass) => {
            const instance = new MalwareClass();
            if (instance.riskLevel.toLowerCase() === riskLevel.toLowerCase()) {
                results.push(instance);
            }
        });
        return results;
    }

    // Get detailed analysis for a specific file
    getDetailedAnalysis(filePath) {
        const filename = filePath.split('\\').pop().toLowerCase();
        const MalwareClass = this.malwareDefinitions.get(filename);
        
        if (MalwareClass) {
            const malware = new MalwareClass();
            return malware.getAnalysisReport();
        }
        
        return null;
    }

    // Get database statistics
    getStatistics() {
        const typeCount = {};
        const riskCount = {};
        
        this.malwareDefinitions.forEach((MalwareClass) => {
            const instance = new MalwareClass();
            typeCount[instance.type] = (typeCount[instance.type] || 0) + 1;
            riskCount[instance.riskLevel] = (riskCount[instance.riskLevel] || 0) + 1;
        });
        
        return {
            total: this.malwareDefinitions.size,
            byType: typeCount,
            byRiskLevel: riskCount
        };
    }
}
