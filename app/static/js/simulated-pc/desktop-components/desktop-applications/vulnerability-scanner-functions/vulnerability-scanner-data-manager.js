/**
 * Data Manager Module for Vulnerability Scanner
 * Handles data manipulation, statistics, and registry management
 */
export class VulnerabilityScannerDataManager {
    constructor(webTargetRegistry, uiRenderer) {
        this.registry = webTargetRegistry;
        this.uiRenderer = uiRenderer;
        this.selectedTarget = null;
    }

    // Target management
    getAllTargets() {
        return this.registry.getAllTargets();
    }

    getTarget(targetId) {
        return this.registry.getTarget(targetId);
    }

    addTarget(targetData) {
        try {
            this.registry.addTarget(targetData);
            return true;
        } catch (error) {
            console.error('Failed to add target:', error);
            return false;
        }
    }

    selectTarget(targetId) {
        const target = this.getTarget(targetId);
        if (target) {
            this.selectedTarget = target;
            return target;
        }
        return null;
    }

    addVulnerabilityToTarget(targetId, vulnerability) {
        return this.registry.addVulnerabilityToTarget(targetId, vulnerability);
    }

    // Statistics and UI updates
    updateStatistics() {
        const stats = this.registry.getTargetStatistics();
        
        this.uiRenderer.elements.totalTargets.textContent = stats.total;
        this.uiRenderer.elements.vulnerableTargets.textContent = stats.vulnerableTargets;
        
        // Calculate total vulnerabilities and high severity count
        const targets = this.getAllTargets();
        const totalVulns = targets.reduce((sum, target) => sum + target.vulnerabilities.length, 0);
        const highSeverity = targets.reduce((sum, target) => {
            return sum + target.vulnerabilities.filter(v => 
                v.severity === 'Critical' || v.severity === 'High'
            ).length;
        }, 0);
        
        this.uiRenderer.elements.totalVulns.textContent = totalVulns;
        this.uiRenderer.elements.highSeverity.textContent = highSeverity;
    }

    populateTargetList() {
        const targets = this.getAllTargets();
        
        // Clear existing options
        this.uiRenderer.elements.targetSelect.innerHTML = '<option value="">Select target...</option>';
        
        // Add targets to select
        targets.forEach(target => {
            const option = document.createElement('option');
            option.value = target.id;
            option.textContent = `${target.name} (${target.url})`;
            this.uiRenderer.elements.targetSelect.appendChild(option);
        });

        // Update targets tab
        this.updateTargetsList();
    }

    updateTargetsList() {
        const targets = this.getAllTargets();
        
        this.uiRenderer.elements.targetsList.innerHTML = targets.map(target => `
            <div class="target-card bg-gray-800 border border-gray-600 p-3 rounded hover:bg-gray-700 transition-colors cursor-pointer">
                <div class="flex justify-between items-start">
                    <div>
                        <h4 class="font-medium text-white">${target.name}</h4>
                        <p class="text-sm text-gray-400">${target.url}</p>
                        <p class="text-xs text-gray-500">${target.description}</p>
                        <div class="flex items-center space-x-2 mt-2">
                            <span class="text-xs text-gray-400">Technology:</span>
                            <span class="text-xs text-gray-300">${target.technology}</span>
                        </div>
                        <div class="flex items-center space-x-2 mt-1">
                            <span class="text-xs text-gray-400">Endpoints:</span>
                            <span class="text-xs text-gray-300">${target.endpoints.length} found</span>
                        </div>
                    </div>
                    <div class="text-right">
                        <span class="inline-block px-2 py-1 text-xs rounded ${this.uiRenderer.getCriticalityColor(target.criticality)}">
                            ${target.criticality}
                        </span>
                        <div class="text-xs text-gray-400 mt-1">
                            ${target.vulnerabilities.length} vulnerabilities
                        </div>
                        <div class="text-xs text-gray-500 mt-1">
                            Last scan: ${target.lastScanned ? new Date(target.lastScanned).toLocaleDateString() : 'Never'}
                        </div>
                    </div>
                </div>
            </div>
        `).join('');
    }

    // Data analysis methods
    getVulnerabilityDistribution() {
        const targets = this.getAllTargets();
        const distribution = {
            'Critical': 0,
            'High': 0,
            'Medium': 0,
            'Low': 0
        };

        targets.forEach(target => {
            target.vulnerabilities.forEach(vuln => {
                if (distribution.hasOwnProperty(vuln.severity)) {
                    distribution[vuln.severity]++;
                }
            });
        });

        return distribution;
    }

    getTargetsByTechnology() {
        const targets = this.getAllTargets();
        const technologies = {};

        targets.forEach(target => {
            const tech = target.technology || 'Unknown';
            if (!technologies[tech]) {
                technologies[tech] = [];
            }
            technologies[tech].push(target);
        });

        return technologies;
    }

    getMostVulnerableTargets(limit = 5) {
        const targets = this.getAllTargets();
        return targets
            .sort((a, b) => b.vulnerabilities.length - a.vulnerabilities.length)
            .slice(0, limit);
    }

    getRecentScans(limit = 10) {
        const targets = this.getAllTargets();
        return targets
            .filter(target => target.lastScanned)
            .sort((a, b) => new Date(b.lastScanned) - new Date(a.lastScanned))
            .slice(0, limit);
    }

    // Export data methods
    exportTargetData() {
        const targets = this.getAllTargets();
        const exportData = {
            timestamp: new Date().toISOString(),
            totalTargets: targets.length,
            targets: targets,
            statistics: this.registry.getTargetStatistics(),
            vulnerabilityDistribution: this.getVulnerabilityDistribution()
        };

        return exportData;
    }

    // Data validation
    validateTargetData(targetData) {
        const required = ['id', 'name', 'url', 'type'];
        for (const field of required) {
            if (!targetData[field]) {
                throw new Error(`Missing required field: ${field}`);
            }
        }

        // Validate URL
        try {
            new URL(targetData.url);
        } catch {
            throw new Error('Invalid URL format');
        }

        return true;
    }

    // Reset all data
    clearAllData() {
        // This would depend on the registry implementation
        // For now, just clear the UI
        this.uiRenderer.elements.vulnerabilitiesContainer.innerHTML = `
            <div class="text-center text-gray-500 py-8">
                <i class="bi bi-shield-check text-4xl mb-4"></i>
                <p>No vulnerabilities found yet. Start a scan to begin testing.</p>
            </div>
        `;
        this.uiRenderer.elements.requestsContainer.innerHTML = `
            <div class="text-center text-gray-500 py-8">
                <i class="bi bi-arrow-left-right text-4xl mb-4"></i>
                <p>HTTP request history will appear here during scanning.</p>
            </div>
        `;
        this.uiRenderer.elements.evidenceContainer.innerHTML = `
            <div class="text-center text-gray-500 py-8">
                <i class="bi bi-camera text-4xl mb-4"></i>
                <p>No evidence collected. Evidence will be gathered during vulnerability detection.</p>
            </div>
        `;
        this.uiRenderer.updateCounters();
        this.updateStatistics();
    }

    // Get current state
    getSelectedTarget() {
        return this.selectedTarget;
    }

    // Refresh all data displays
    refresh() {
        this.populateTargetList();
        this.updateStatistics();
    }
}
