/**
 * Tab Manager Module for Vulnerability Scanner
 * Handles tab switching and tab-related functionality
 */
export class VulnerabilityScannerTabManager {
    constructor(container) {
        this.container = container;
        this.activeTab = 'vulnerabilities';
        this.tabButtons = null;
        this.tabPanes = null;
    }

    bindTabEvents() {
        this.tabButtons = this.container.querySelectorAll('.tab-btn');
        this.tabPanes = this.container.querySelectorAll('.tab-pane');

        this.tabButtons.forEach((btn, index) => {
            btn.addEventListener('click', () => {
                const tabName = btn.dataset.tab;
                this.switchToTab(tabName);
            });

            // Add keyboard navigation for tabs (WCAG 2.1 AAA requirement)
            btn.addEventListener('keydown', (e) => {
                switch (e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        this.focusPreviousTab(index);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        this.focusNextTab(index);
                        break;
                    case 'Home':
                        e.preventDefault();
                        this.focusFirstTab();
                        break;
                    case 'End':
                        e.preventDefault();
                        this.focusLastTab();
                        break;
                    case 'Enter':
                    case ' ':
                        e.preventDefault();
                        this.switchToTab(btn.dataset.tab);
                        break;
                }
            });
        });
    }

    focusPreviousTab(currentIndex) {
        const prevIndex = currentIndex === 0 ? this.tabButtons.length - 1 : currentIndex - 1;
        this.tabButtons[prevIndex].focus();
    }

    focusNextTab(currentIndex) {
        const nextIndex = currentIndex === this.tabButtons.length - 1 ? 0 : currentIndex + 1;
        this.tabButtons[nextIndex].focus();
    }

    focusFirstTab() {
        this.tabButtons[0].focus();
    }

    focusLastTab() {
        this.tabButtons[this.tabButtons.length - 1].focus();
    }

    switchToTab(tabName) {
        if (!this.tabButtons || !this.tabPanes) {
            console.warn('Tab elements not initialized');
            return;
        }

        // Update button states with WCAG 2.1 AAA compliant colors and ARIA attributes
        this.tabButtons.forEach(btn => {
            btn.classList.remove('active', 'bg-blue-600', 'text-white');
            btn.classList.add('text-gray-100', 'hover:text-white', 'hover:bg-gray-700');
            btn.setAttribute('aria-selected', 'false');
            btn.setAttribute('tabindex', '-1');
        });

        // Find and activate the clicked tab button
        const activeButton = Array.from(this.tabButtons).find(btn => btn.dataset.tab === tabName);
        if (activeButton) {
            activeButton.classList.add('active', 'bg-blue-600', 'text-white');
            activeButton.classList.remove('text-gray-100', 'hover:text-white', 'hover:bg-gray-700');
            activeButton.setAttribute('aria-selected', 'true');
            activeButton.setAttribute('tabindex', '0');
        }
        
        // Update pane visibility and ARIA attributes
        this.tabPanes.forEach(pane => {
            pane.classList.add('hidden');
            pane.classList.remove('active');
            pane.setAttribute('aria-hidden', 'true');
        });
        
        const targetPane = document.getElementById(`${tabName}Tab`);
        if (targetPane) {
            targetPane.classList.remove('hidden');
            targetPane.classList.add('active');
            targetPane.setAttribute('aria-hidden', 'false');
            this.activeTab = tabName;
            
            // Trigger custom event for tab switch
            this.container.dispatchEvent(new CustomEvent('tabSwitched', {
                detail: { tabName }
            }));

            // Announce tab change to screen readers
            this.announceTabChange(tabName);
        }
    }

    announceTabChange(tabName) {
        const announcements = document.getElementById('announcements');
        if (announcements) {
            const tabLabels = {
                'vulnerabilities': 'Vulnerabilities',
                'requests': 'HTTP Requests',
                'evidence': 'Evidence',
                'targets': 'Target Management'
            };
            
            const label = tabLabels[tabName] || tabName;
            announcements.textContent = `Switched to ${label} tab`;
            
            // Clear after announcement
            setTimeout(() => {
                announcements.textContent = '';
            }, 1000);
        }
    }

    getActiveTab() {
        return this.activeTab;
    }

    getTabCount(tabName) {
        const button = Array.from(this.tabButtons || []).find(btn => btn.dataset.tab === tabName);
        if (button) {
            const countElement = button.querySelector('span');
            return countElement ? parseInt(countElement.textContent) || 0 : 0;
        }
        return 0;
    }

    updateTabCount(tabName, count) {
        const button = Array.from(this.tabButtons || []).find(btn => btn.dataset.tab === tabName);
        if (button) {
            const countElement = button.querySelector('span');
            if (countElement) {
                countElement.textContent = count.toString();
            }
        }
    }

    highlightTab(tabName, highlight = true) {
        const button = Array.from(this.tabButtons || []).find(btn => btn.dataset.tab === tabName);
        if (button) {
            if (highlight) {
                button.classList.add('animate-pulse');
                button.style.boxShadow = '0 0 10px rgba(34, 197, 94, 0.5)';
            } else {
                button.classList.remove('animate-pulse');
                button.style.boxShadow = '';
            }
        }
    }

    disableTab(tabName, disabled = true) {
        const button = Array.from(this.tabButtons || []).find(btn => btn.dataset.tab === tabName);
        if (button) {
            if (disabled) {
                button.disabled = true;
                button.classList.add('opacity-50', 'cursor-not-allowed');
                button.classList.remove('cursor-pointer');
            } else {
                button.disabled = false;
                button.classList.remove('opacity-50', 'cursor-not-allowed');
                button.classList.add('cursor-pointer');
            }
        }
    }

    // Add notification badge to tab
    addNotificationBadge(tabName, count = 1) {
        const button = Array.from(this.tabButtons || []).find(btn => btn.dataset.tab === tabName);
        if (button) {
            let badge = button.querySelector('.notification-badge');
            if (!badge) {
                badge = document.createElement('span');
                badge.className = 'notification-badge absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center';
                button.style.position = 'relative';
                button.appendChild(badge);
            }
            badge.textContent = count > 99 ? '99+' : count.toString();
        }
    }

    removeNotificationBadge(tabName) {
        const button = Array.from(this.tabButtons || []).find(btn => btn.dataset.tab === tabName);
        if (button) {
            const badge = button.querySelector('.notification-badge');
            if (badge) {
                badge.remove();
            }
        }
    }

    // Get all available tabs
    getAllTabs() {
        return Array.from(this.tabButtons || []).map(btn => ({
            name: btn.dataset.tab,
            element: btn,
            active: btn.classList.contains('active'),
            disabled: btn.disabled
        }));
    }

    // Navigate to next/previous tab
    navigateTab(direction = 'next') {
        const tabs = this.getAllTabs().filter(tab => !tab.disabled);
        const currentIndex = tabs.findIndex(tab => tab.active);
        
        if (currentIndex === -1) return;

        let nextIndex;
        if (direction === 'next') {
            nextIndex = (currentIndex + 1) % tabs.length;
        } else {
            nextIndex = currentIndex === 0 ? tabs.length - 1 : currentIndex - 1;
        }

        this.switchToTab(tabs[nextIndex].name);
    }

    // Initialize default tab state
    initializeDefaultState() {
        // Ensure vulnerabilities tab is active by default
        this.switchToTab('vulnerabilities');
    }

    // Reset tab state
    resetTabState() {
        // Reset all counts
        this.updateTabCount('vulnerabilities', 0);
        this.updateTabCount('requests', 0);
        this.updateTabCount('evidence', 0);
        
        // Remove all badges
        this.removeNotificationBadge('vulnerabilities');
        this.removeNotificationBadge('requests');
        this.removeNotificationBadge('evidence');
        this.removeNotificationBadge('targets');
        
        // Remove highlights
        this.highlightTab('vulnerabilities', false);
        this.highlightTab('requests', false);
        this.highlightTab('evidence', false);
        this.highlightTab('targets', false);
        
        // Switch back to default tab
        this.initializeDefaultState();
    }

    // Cleanup
    destroy() {
        // Remove event listeners if needed
        if (this.tabButtons) {
            this.tabButtons.forEach(btn => {
                btn.replaceWith(btn.cloneNode(true));
            });
        }
    }
}
