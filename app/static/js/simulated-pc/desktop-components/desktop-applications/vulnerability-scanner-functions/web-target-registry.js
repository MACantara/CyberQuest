import { WebTarget } from '../../../levels/level-four/vulnerability-scanner-targets/web-target-base.js';
import { 
    getAllMunicipalityVotingTargets, 
    getMunicipalityVotingGroupConfig 
} from '../../../levels/level-four/vulnerability-scanner-targets/municipality-voting/index.js';

export class WebTargetRegistry {
    constructor() {
        this.targets = new Map();
        this.targetGroups = new Map();
        this.initialized = false;
        
        // Initialize with municipality voting system targets synchronously
        this.initializeTargets();
    }

    /**
     * Initialize targets from modular target files
     */
    initializeTargets() {
        if (this.initialized) return;
        
        try {
            // Load municipality voting targets
            this.loadMunicipalityTargets();
            
            // Load target group configurations
            this.loadTargetGroups();
            
            this.initialized = true;
            console.log('[WebTargetRegistry] Initialized with modular target system');
        } catch (error) {
            console.error('[WebTargetRegistry] Failed to initialize targets:', error);
            // Fallback to empty registry
            this.initialized = true;
        }
    }

    /**
     * Load municipality voting system targets
     */
    loadMunicipalityTargets() {
        try {
            const targets = getAllMunicipalityVotingTargets();
            targets.forEach(target => {
                this.targets.set(target.id, target);
            });
            console.log(`[WebTargetRegistry] Loaded ${targets.length} municipality voting targets`);
        } catch (error) {
            console.error('[WebTargetRegistry] Failed to load municipality targets:', error);
        }
    }

    /**
     * Load target group configurations
     */
    loadTargetGroups() {
        try {
            const groupConfig = getMunicipalityVotingGroupConfig();
            this.targetGroups.set(groupConfig.id, groupConfig);
            console.log(`[WebTargetRegistry] Loaded target group: ${groupConfig.name}`);
        } catch (error) {
            console.error('[WebTargetRegistry] Failed to load target groups:', error);
        }
    }

    /**
     * Add a target to the registry
     * @param {Object|WebTarget} targetData - Target data or WebTarget instance
     * @returns {WebTarget} The created/added target
     */
    addTarget(targetData) {
        const target = targetData instanceof WebTarget ? targetData : new WebTarget(targetData);
        this.targets.set(target.id, target);
        return target;
    }

    /**
     * Get a target by ID
     * @param {string} id - Target ID
     * @returns {WebTarget|undefined} Target instance or undefined
     */
    getTarget(id) {
        return this.targets.get(id);
    }

    getAllTargets() {
        return Array.from(this.targets.values());
    }

    getTargetsByType(type) {
        return Array.from(this.targets.values())
            .filter(target => target.type === type);
    }

    getTargetsByCriticality(criticality) {
        return Array.from(this.targets.values())
            .filter(target => target.criticality === criticality);
    }

    createTargetGroup(id, name, targetIds) {
        const group = {
            id,
            name,
            targetIds: targetIds || [],
            created: new Date().toISOString()
        };
        this.targetGroups.set(id, group);
        return group;
    }

    getTargetGroup(id) {
        return this.targetGroups.get(id);
    }

    getTargetsInGroup(groupId) {
        const group = this.targetGroups.get(groupId);
        if (!group) return [];
        
        return group.targetIds.map(id => this.targets.get(id)).filter(Boolean);
    }

    updateTargetStatus(targetId, status) {
        const target = this.targets.get(targetId);
        if (target) {
            target.status = status;
            target.lastUpdated = new Date().toISOString();
        }
    }

    addVulnerabilityToTarget(targetId, vulnerability) {
        const target = this.targets.get(targetId);
        if (target) {
            target.vulnerabilities.push(vulnerability);
            target.lastScanned = new Date().toISOString();
        }
    }

    getTargetsWithVulnerabilities() {
        return Array.from(this.targets.values())
            .filter(target => target.vulnerabilities.length > 0);
    }

    searchTargets(query) {
        const lowercaseQuery = query.toLowerCase();
        return Array.from(this.targets.values()).filter(target => 
            target.name.toLowerCase().includes(lowercaseQuery) ||
            target.description.toLowerCase().includes(lowercaseQuery) ||
            target.url.toLowerCase().includes(lowercaseQuery)
        );
    }

    getTargetStatistics() {
        const targets = Array.from(this.targets.values());
        
        return {
            total: targets.length,
            byType: this.groupBy(targets, 'type'),
            byCriticality: this.groupBy(targets, 'criticality'),
            byStatus: this.groupBy(targets, 'status'),
            vulnerableTargets: targets.filter(t => t.vulnerabilities.length > 0).length,
            lastScanned: targets.reduce((latest, target) => {
                if (!target.lastScanned) return latest;
                return !latest || new Date(target.lastScanned) > new Date(latest) 
                    ? target.lastScanned 
                    : latest;
            }, null)
        };
    }

    groupBy(array, property) {
        return array.reduce((acc, item) => {
            const key = item[property];
            acc[key] = (acc[key] || 0) + 1;
            return acc;
        }, {});
    }

    exportTargets() {
        return {
            targets: Object.fromEntries(this.targets),
            targetGroups: Object.fromEntries(this.targetGroups),
            exported: new Date().toISOString()
        };
    }

    importTargets(data) {
        if (data.targets) {
            for (const [id, targetData] of Object.entries(data.targets)) {
                this.targets.set(id, new WebTarget(targetData));
            }
        }
        
        if (data.targetGroups) {
            for (const [id, groupData] of Object.entries(data.targetGroups)) {
                this.targetGroups.set(id, groupData);
            }
        }
    }
}

// Create singleton instance with proper initialization
const registryInstance = new WebTargetRegistry();

// Export singleton instance
export const webTargetRegistry = registryInstance;
