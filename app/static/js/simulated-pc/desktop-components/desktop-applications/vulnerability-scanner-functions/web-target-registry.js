import { WebTarget, loadTargetGroup, loadTargetById, getAllTargetGroupConfigs } from './targets/index.js';

export class WebTargetRegistry {
    constructor() {
        this.targets = new Map();
        this.targetGroups = new Map();
        this.initialized = false;
        
        // Initialize with municipality voting system targets
        this.initializeTargets();
    }

    /**
     * Initialize targets from modular target files
     */
    async initializeTargets() {
        if (this.initialized) return;
        
        try {
            // Load municipality voting targets
            await this.loadMunicipalityTargets();
            
            // Load target group configurations
            await this.loadTargetGroups();
            
            this.initialized = true;
            console.log('[WebTargetRegistry] Initialized with modular target system');
        } catch (error) {
            console.error('[WebTargetRegistry] Failed to initialize targets:', error);
            // Fallback to empty registry
            this.initialized = true;
        }
    }

    /**
     * Load municipality voting system targets
     */
    async loadMunicipalityTargets() {
        try {
            const targets = await loadTargetGroup('municipality-voting');
            targets.forEach(target => {
                this.targets.set(target.id, target);
            });
            console.log(`[WebTargetRegistry] Loaded ${targets.length} municipality voting targets`);
        } catch (error) {
            console.error('[WebTargetRegistry] Failed to load municipality targets:', error);
        }
    }

    /**
     * Load target group configurations
     */
    async loadTargetGroups() {
        try {
            const groupConfigs = await getAllTargetGroupConfigs();
            groupConfigs.forEach(config => {
                this.targetGroups.set(config.id, config);
            });
            console.log(`[WebTargetRegistry] Loaded ${groupConfigs.length} target groups`);
        } catch (error) {
            console.error('[WebTargetRegistry] Failed to load target groups:', error);
        }
    }

    /**
     * Add a target to the registry
     * @param {Object|WebTarget} targetData - Target data or WebTarget instance
     * @returns {WebTarget} The created/added target
     */
    addTarget(targetData) {
        const target = targetData instanceof WebTarget ? targetData : new WebTarget(targetData);
        this.targets.set(target.id, target);
        return target;
    }

    /**
     * Get a target by ID
     * @param {string} id - Target ID
     * @returns {WebTarget|undefined} Target instance or undefined
     */
    getTarget(id) {
        return this.targets.get(id);
    }

    /**
     * Get a target by ID, with async loading fallback
     * @param {string} id - Target ID
     * @returns {Promise<WebTarget|null>} Target instance or null
     */
    async getTargetAsync(id) {
        // Try to get from cache first
        let target = this.targets.get(id);
        if (target) return target;
        
        // Try to load dynamically
        try {
            target = await loadTargetById(id);
            if (target) {
                this.targets.set(target.id, target);
                return target;
            }
        } catch (error) {
            console.warn(`[WebTargetRegistry] Failed to load target '${id}':`, error);
        }
        
        return null;
    }

    getAllTargets() {
        return Array.from(this.targets.values());
    }

    getTargetsByType(type) {
        return Array.from(this.targets.values())
            .filter(target => target.type === type);
    }

    getTargetsByCriticality(criticality) {
        return Array.from(this.targets.values())
            .filter(target => target.criticality === criticality);
    }

    createTargetGroup(id, name, targetIds) {
        const group = {
            id,
            name,
            targetIds: targetIds || [],
            created: new Date().toISOString()
        };
        this.targetGroups.set(id, group);
        return group;
    }

    getTargetGroup(id) {
        return this.targetGroups.get(id);
    }

    getTargetsInGroup(groupId) {
        const group = this.targetGroups.get(groupId);
        if (!group) return [];
        
        return group.targetIds.map(id => this.targets.get(id)).filter(Boolean);
    }

    /**
     * Reload a specific target group
     * @param {string} groupId - Group ID to reload
     * @returns {Promise<Array>} Promise resolving to loaded targets
     */
    async reloadTargetGroup(groupId) {
        try {
            const targets = await loadTargetGroup(groupId);
            
            // Remove existing targets from this group
            const existingGroup = this.targetGroups.get(groupId);
            if (existingGroup) {
                existingGroup.targetIds.forEach(id => {
                    this.targets.delete(id);
                });
            }
            
            // Add new targets
            targets.forEach(target => {
                this.targets.set(target.id, target);
            });
            
            console.log(`[WebTargetRegistry] Reloaded ${targets.length} targets for group '${groupId}'`);
            return targets;
        } catch (error) {
            console.error(`[WebTargetRegistry] Failed to reload group '${groupId}':`, error);
            return [];
        }
    }

    /**
     * Add a new target group dynamically
     * @param {string} groupId - Group ID to add
     * @returns {Promise<boolean>} Success status
     */
    async addTargetGroup(groupId) {
        try {
            const targets = await loadTargetGroup(groupId);
            const groupConfigs = await getAllTargetGroupConfigs();
            const groupConfig = groupConfigs.find(config => config.id === groupId);
            
            if (groupConfig) {
                this.targetGroups.set(groupId, groupConfig);
                targets.forEach(target => {
                    this.targets.set(target.id, target);
                });
                
                console.log(`[WebTargetRegistry] Added target group '${groupId}' with ${targets.length} targets`);
                return true;
            }
            
            return false;
        } catch (error) {
            console.error(`[WebTargetRegistry] Failed to add group '${groupId}':`, error);
            return false;
        }
    }

    updateTargetStatus(targetId, status) {
        const target = this.targets.get(targetId);
        if (target) {
            target.status = status;
            target.lastUpdated = new Date().toISOString();
        }
    }

    addVulnerabilityToTarget(targetId, vulnerability) {
        const target = this.targets.get(targetId);
        if (target) {
            target.vulnerabilities.push(vulnerability);
            target.lastScanned = new Date().toISOString();
        }
    }

    getTargetsWithVulnerabilities() {
        return Array.from(this.targets.values())
            .filter(target => target.vulnerabilities.length > 0);
    }

    searchTargets(query) {
        const lowercaseQuery = query.toLowerCase();
        return Array.from(this.targets.values()).filter(target => 
            target.name.toLowerCase().includes(lowercaseQuery) ||
            target.description.toLowerCase().includes(lowercaseQuery) ||
            target.url.toLowerCase().includes(lowercaseQuery)
        );
    }

    getTargetStatistics() {
        const targets = Array.from(this.targets.values());
        
        return {
            total: targets.length,
            byType: this.groupBy(targets, 'type'),
            byCriticality: this.groupBy(targets, 'criticality'),
            byStatus: this.groupBy(targets, 'status'),
            vulnerableTargets: targets.filter(t => t.vulnerabilities.length > 0).length,
            lastScanned: targets.reduce((latest, target) => {
                if (!target.lastScanned) return latest;
                return !latest || new Date(target.lastScanned) > new Date(latest) 
                    ? target.lastScanned 
                    : latest;
            }, null)
        };
    }

    groupBy(array, property) {
        return array.reduce((acc, item) => {
            const key = item[property];
            acc[key] = (acc[key] || 0) + 1;
            return acc;
        }, {});
    }

    exportTargets() {
        return {
            targets: Object.fromEntries(this.targets),
            targetGroups: Object.fromEntries(this.targetGroups),
            exported: new Date().toISOString()
        };
    }

    importTargets(data) {
        if (data.targets) {
            for (const [id, targetData] of Object.entries(data.targets)) {
                this.targets.set(id, new WebTarget(targetData));
            }
        }
        
        if (data.targetGroups) {
            for (const [id, groupData] of Object.entries(data.targetGroups)) {
                this.targetGroups.set(id, groupData);
            }
        }
    }
}

// Create singleton instance with proper initialization
const registryInstance = new WebTargetRegistry();

// Export singleton instance
export const webTargetRegistry = registryInstance;
