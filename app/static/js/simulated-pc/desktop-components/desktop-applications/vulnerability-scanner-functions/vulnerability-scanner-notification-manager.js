/**
 * Notification Manager Module for Vulnerability Scanner
 * Handles all notification display and management
 */
export class VulnerabilityScannerNotificationManager {
    constructor() {
        this.notifications = [];
        this.maxNotifications = 5;
        this.defaultDuration = 3000;
    }

    show(message, type = 'info', options = {}) {
        const notification = this.createNotification(message, type, options);
        this.displayNotification(notification);
        return notification.id;
    }

    createNotification(message, type, options) {
        const id = `notification-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const duration = options.duration || this.defaultDuration;
        const persistent = options.persistent || false;
        const actions = options.actions || [];

        const notification = {
            id,
            message,
            type,
            duration,
            persistent,
            actions,
            timestamp: new Date(),
            element: null
        };

        return notification;
    }

    displayNotification(notification) {
        // Create notification element
        const element = document.createElement('div');
        element.id = notification.id;
        element.className = this.getNotificationClasses(notification.type);
        
        // Create notification content
        element.innerHTML = this.createNotificationHTML(notification);
        
        // Store element reference
        notification.element = element;
        
        // Add to notifications array
        this.notifications.push(notification);
        
        // Remove oldest notifications if limit exceeded
        if (this.notifications.length > this.maxNotifications) {
            const oldest = this.notifications.shift();
            this.removeNotification(oldest.id);
        }
        
        // Add to DOM
        this.getNotificationContainer().appendChild(element);
        
        // Add entrance animation
        this.animateIn(element);
        
        // Set auto-remove timer if not persistent
        if (!notification.persistent && notification.duration > 0) {
            setTimeout(() => {
                this.removeNotification(notification.id);
            }, notification.duration);
        }
        
        // Bind action events
        this.bindNotificationEvents(notification);
    }

    createNotificationHTML(notification) {
        const icon = this.getNotificationIcon(notification.type);
        const actionsHTML = notification.actions.length > 0 
            ? `<div class="notification-actions mt-2 flex space-x-2" role="group" aria-label="Notification actions">
                ${notification.actions.map(action => 
                    `<button class="notification-action px-2 py-1 text-xs rounded border border-white border-opacity-30 hover:bg-white/20 focus:bg-white/20 transition-colors focus:outline-none focus:ring-2 focus:ring-white focus:ring-opacity-50" 
                             data-action="${action.id}"
                             aria-describedby="${action.id}-desc">
                        ${action.label}
                    </button>`
                ).join('')}
            </div>`
            : '';

        return `
            <div class="flex items-start" role="alert" aria-live="${notification.persistent ? 'assertive' : 'polite'}">
                <div class="flex-shrink-0" aria-hidden="true">
                    <i class="bi ${icon} text-lg mr-3"></i>
                </div>
                <div class="flex-1">
                    <div class="notification-message text-sm font-medium" id="notification-message-${notification.id}">
                        ${notification.message}
                    </div>
                    ${actionsHTML}
                </div>
                ${!notification.persistent ? `
                    <button class="notification-close flex-shrink-0 ml-3 text-white text-opacity-70 hover:text-opacity-100 focus:text-opacity-100 transition-opacity focus:outline-none focus:ring-2 focus:ring-white focus:ring-opacity-50 rounded" 
                            aria-label="Close notification"
                            aria-describedby="notification-message-${notification.id}">
                        <i class="bi bi-x text-lg" aria-hidden="true"></i>
                    </button>
                ` : ''}
            </div>
        `;
    }

    getNotificationClasses(type) {
        // WCAG 2.1 AAA compliant notification colors with enhanced contrast
        const baseClasses = 'fixed top-4 right-4 px-4 py-3 rounded-lg text-white text-sm z-50 max-w-sm shadow-lg border transition-all duration-300 transform focus-within:ring-2 focus-within:ring-white focus-within:ring-opacity-50';
        
        const typeClasses = {
            'success': 'bg-green-700 border-green-600 text-white',
            'error': 'bg-red-700 border-red-600 text-white',
            'warning': 'bg-yellow-700 border-yellow-600 text-white',
            'info': 'bg-blue-700 border-blue-600 text-white'
        };
        
        return `${baseClasses} ${typeClasses[type] || typeClasses.info}`;
    }

    getNotificationIcon(type) {
        const icons = {
            'success': 'bi-check-circle',
            'error': 'bi-exclamation-triangle',
            'warning': 'bi-exclamation-circle',
            'info': 'bi-info-circle'
        };
        
        return icons[type] || icons.info;
    }

    getNotificationContainer() {
        let container = document.getElementById('notification-container');
        if (!container) {
            container = document.createElement('div');
            container.id = 'notification-container';
            container.className = 'fixed top-4 right-4 z-50 space-y-2';
            document.body.appendChild(container);
        }
        return container;
    }

    bindNotificationEvents(notification) {
        const element = notification.element;
        
        // Close button
        const closeBtn = element.querySelector('.notification-close');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                this.removeNotification(notification.id);
            });
        }
        
        // Action buttons
        const actionBtns = element.querySelectorAll('.notification-action');
        actionBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const actionId = btn.dataset.action;
                const action = notification.actions.find(a => a.id === actionId);
                if (action && action.callback) {
                    action.callback(notification);
                }
                
                // Remove notification after action unless specified otherwise
                if (!action || action.dismissAfterAction !== false) {
                    this.removeNotification(notification.id);
                }
            });
        });
    }

    animateIn(element) {
        element.style.transform = 'translateX(100%)';
        element.style.opacity = '0';
        
        // Trigger reflow
        element.offsetHeight;
        
        element.style.transform = 'translateX(0)';
        element.style.opacity = '1';
    }

    animateOut(element) {
        return new Promise(resolve => {
            element.style.transform = 'translateX(100%)';
            element.style.opacity = '0';
            
            setTimeout(() => {
                resolve();
            }, 300);
        });
    }

    async removeNotification(id) {
        const notification = this.notifications.find(n => n.id === id);
        if (!notification || !notification.element) return;
        
        // Animate out
        await this.animateOut(notification.element);
        
        // Remove from DOM
        if (notification.element.parentNode) {
            notification.element.parentNode.removeChild(notification.element);
        }
        
        // Remove from array
        this.notifications = this.notifications.filter(n => n.id !== id);
    }

    // Predefined notification types for common scanner events
    showScanStarted(targetName) {
        return this.show(`Started vulnerability scan for ${targetName}`, 'info', {
            actions: [{
                id: 'view-progress',
                label: 'View Progress',
                callback: () => {
                    // Switch to appropriate tab or view
                    document.dispatchEvent(new CustomEvent('showScanProgress'));
                }
            }]
        });
    }

    showScanCompleted(vulnerabilityCount) {
        const message = vulnerabilityCount > 0 
            ? `Scan completed! Found ${vulnerabilityCount} vulnerability${vulnerabilityCount !== 1 ? 'ies' : ''}`
            : 'Scan completed! No vulnerabilities found';
        
        return this.show(message, vulnerabilityCount > 0 ? 'warning' : 'success', {
            duration: 5000,
            actions: [{
                id: 'view-results',
                label: 'View Results',
                callback: () => {
                    document.dispatchEvent(new CustomEvent('showScanResults'));
                }
            }]
        });
    }

    showVulnerabilityFound(vulnerability) {
        return this.show(`${vulnerability.severity} vulnerability found: ${vulnerability.title}`, 'warning', {
            duration: 4000,
            actions: [{
                id: 'view-vulnerability',
                label: 'View Details',
                callback: () => {
                    document.dispatchEvent(new CustomEvent('showVulnerabilityDetails', {
                        detail: { vulnerability }
                    }));
                }
            }]
        });
    }

    showTargetAdded(targetName) {
        return this.show(`Target "${targetName}" added successfully`, 'success');
    }

    showExportCompleted() {
        return this.show('Scan results exported successfully', 'success');
    }

    // Batch operations
    clearAll() {
        const notificationIds = this.notifications.map(n => n.id);
        notificationIds.forEach(id => this.removeNotification(id));
    }

    // Get notification statistics
    getStats() {
        return {
            total: this.notifications.length,
            byType: this.notifications.reduce((acc, n) => {
                acc[n.type] = (acc[n.type] || 0) + 1;
                return acc;
            }, {}),
            persistent: this.notifications.filter(n => n.persistent).length
        };
    }

    // Configuration
    setMaxNotifications(max) {
        this.maxNotifications = max;
        
        // Remove excess notifications if needed
        while (this.notifications.length > max) {
            const oldest = this.notifications.shift();
            this.removeNotification(oldest.id);
        }
    }

    setDefaultDuration(duration) {
        this.defaultDuration = duration;
    }

    // Cleanup
    destroy() {
        this.clearAll();
        const container = document.getElementById('notification-container');
        if (container && container.parentNode) {
            container.parentNode.removeChild(container);
        }
    }
}
