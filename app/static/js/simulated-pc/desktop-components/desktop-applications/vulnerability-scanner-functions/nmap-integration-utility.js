/**
 * Nmap Integration Utility
 * Provides integration between the vulnerability scanner and nmap command results
 */
export class NmapIntegrationUtility {
    constructor() {
        this.vulnerabilityScannerApp = null;
    }

    /**
     * Initialize with vulnerability scanner app reference
     * @param {VulnerabilityScannerApp} app - The vulnerability scanner app instance
     */
    initialize(app) {
        this.vulnerabilityScannerApp = app;
    }

    /**
     * Auto-integrate nmap results from terminal
     * This can be called from the nmap command after execution
     * @param {string} nmapOutput - Raw nmap command output
     * @param {string} target - Target that was scanned
     */
    autoIntegrateResults(nmapOutput, target) {
        if (!this.vulnerabilityScannerApp) {
            console.warn('Vulnerability scanner app not initialized for nmap integration');
            return false;
        }

        try {
            // Check if vulnerability scanner is open
            if (!this.isVulnerabilityScannerOpen()) {
                console.log('Vulnerability scanner not open, storing nmap data for later integration');
                this.storePendingIntegration(nmapOutput, target);
                return false;
            }

            // Integrate the results
            const result = this.vulnerabilityScannerApp.integrateNmapResults(nmapOutput);
            
            // Show notification about integration
            this.showIntegrationNotification(result, target);
            
            return true;
        } catch (error) {
            console.error('Failed to auto-integrate nmap results:', error);
            return false;
        }
    }

    /**
     * Check if vulnerability scanner window is open
     */
    isVulnerabilityScannerOpen() {
        // Check if there's a vulnerability scanner window open
        const vulnWindow = document.querySelector('[data-window-type="vulnerability-scanner"]');
        return vulnWindow !== null;
    }

    /**
     * Store nmap data for later integration
     */
    storePendingIntegration(nmapOutput, target) {
        const pendingData = {
            timestamp: new Date().toISOString(),
            output: nmapOutput,
            target: target,
            integrated: false
        };

        // Store in localStorage for persistence
        const existing = JSON.parse(localStorage.getItem('pendingNmapIntegrations') || '[]');
        existing.push(pendingData);
        
        // Keep only last 10 integrations
        if (existing.length > 10) {
            existing.splice(0, existing.length - 10);
        }
        
        localStorage.setItem('pendingNmapIntegrations', JSON.stringify(existing));
        
        console.log('Nmap data stored for later integration. Open vulnerability scanner to integrate.');
    }

    /**
     * Get pending integrations
     */
    getPendingIntegrations() {
        return JSON.parse(localStorage.getItem('pendingNmapIntegrations') || '[]')
            .filter(item => !item.integrated);
    }

    /**
     * Process all pending integrations
     */
    processPendingIntegrations() {
        if (!this.vulnerabilityScannerApp) return 0;

        const pending = this.getPendingIntegrations();
        let processed = 0;

        pending.forEach(item => {
            try {
                this.vulnerabilityScannerApp.integrateNmapResults(item.output);
                item.integrated = true;
                processed++;
            } catch (error) {
                console.error('Failed to process pending nmap integration:', error);
            }
        });

        // Update storage
        if (processed > 0) {
            const all = JSON.parse(localStorage.getItem('pendingNmapIntegrations') || '[]');
            localStorage.setItem('pendingNmapIntegrations', JSON.stringify(all));
            
            this.vulnerabilityScannerApp.showNotification(
                `Integrated ${processed} pending nmap scan${processed > 1 ? 's' : ''}`,
                'success'
            );
        }

        return processed;
    }

    /**
     * Show integration notification
     */
    showIntegrationNotification(result, target) {
        if (!this.vulnerabilityScannerApp) return;

        const message = `Nmap scan integrated for ${target}: ${result.vulnerabilities.length} vulnerabilities, ${result.ports.length} ports`;
        this.vulnerabilityScannerApp.showNotification(message, 'success');
    }

    /**
     * Enhanced nmap output parsing with better vulnerability detection
     */
    parseNmapOutput(output) {
        const parsed = {
            hosts: [],
            ports: [],
            services: [],
            vulnerabilities: [],
            osInfo: [],
            scripts: []
        };

        if (!output || typeof output !== 'string') {
            return parsed;
        }

        const lines = output.split('\n');
        let currentHost = null;
        let inScriptResults = false;
        let currentScript = null;

        lines.forEach((line, index) => {
            const trimmedLine = line.trim();
            
            // Parse host information
            const hostMatch = trimmedLine.match(/Nmap scan report for (.+?)(\s+\((.+)\))?/);
            if (hostMatch) {
                currentHost = {
                    hostname: hostMatch[1],
                    ip: hostMatch[3] || hostMatch[1],
                    ports: [],
                    services: [],
                    vulnerabilities: []
                };
                parsed.hosts.push(currentHost);
                return;
            }

            // Parse port information
            const portMatch = trimmedLine.match(/(\d+)\/(tcp|udp)\s+(\w+)\s+(.+)/);
            if (portMatch && currentHost) {
                const portInfo = {
                    port: parseInt(portMatch[1]),
                    protocol: portMatch[2],
                    state: portMatch[3],
                    service: portMatch[4],
                    host: currentHost.ip
                };
                
                parsed.ports.push(portInfo);
                currentHost.ports.push(portInfo);
                return;
            }

            // Parse script results
            if (trimmedLine.startsWith('|')) {
                inScriptResults = true;
                
                // Check for vulnerability indicators
                if (this.isVulnerabilityLine(trimmedLine)) {
                    const vuln = this.extractVulnerabilityFromLine(trimmedLine, currentHost);
                    if (vuln) {
                        parsed.vulnerabilities.push(vuln);
                        if (currentHost) {
                            currentHost.vulnerabilities.push(vuln);
                        }
                    }
                }
            }

            // Parse OS information
            if (trimmedLine.includes('Running:') || trimmedLine.includes('OS:')) {
                const osInfo = {
                    line: trimmedLine,
                    host: currentHost?.ip || 'unknown'
                };
                parsed.osInfo.push(osInfo);
            }

            // Parse service versions
            if (trimmedLine.includes('Version:') && currentHost) {
                parsed.services.push({
                    host: currentHost.ip,
                    info: trimmedLine
                });
            }
        });

        return parsed;
    }

    /**
     * Check if a line contains vulnerability information
     */
    isVulnerabilityLine(line) {
        const vulnerabilityIndicators = [
            'CVE-',
            'CRITICAL',
            'HIGH',
            'MEDIUM',
            'VULNERABLE',
            'EXPLOIT',
            'DoS',
            'Buffer Overflow',
            'SQL Injection',
            'XSS',
            'Path Traversal',
            'Remote Code Execution',
            'Authentication Bypass',
            'Privilege Escalation'
        ];

        const upperLine = line.toUpperCase();
        return vulnerabilityIndicators.some(indicator => 
            upperLine.includes(indicator.toUpperCase())
        );
    }

    /**
     * Extract vulnerability information from a line
     */
    extractVulnerabilityFromLine(line, host) {
        const cveMatch = line.match(/CVE-\d{4}-\d{4,}/);
        const cve = cveMatch ? cveMatch[0] : null;

        const severity = this.extractSeverityFromLine(line);
        const title = this.extractTitleFromLine(line);
        
        return {
            id: cve || `nmap-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            cve: cve,
            title: title,
            description: `Network vulnerability detected via nmap: ${line.replace(/^\|\s*/, '').trim()}`,
            severity: severity,
            category: 'Network Security',
            source: 'nmap',
            host: host?.ip || 'unknown',
            hostname: host?.hostname || 'unknown',
            evidence: [line.trim()],
            discoveredAt: new Date().toISOString()
        };
    }

    /**
     * Extract severity from line
     */
    extractSeverityFromLine(line) {
        const upperLine = line.toUpperCase();
        
        if (upperLine.includes('CRITICAL')) return 'critical';
        if (upperLine.includes('HIGH')) return 'high';
        if (upperLine.includes('MEDIUM')) return 'medium';
        if (upperLine.includes('LOW')) return 'low';
        
        // CVE severity determination based on description
        if (upperLine.includes('REMOTE CODE EXECUTION') || 
            upperLine.includes('BUFFER OVERFLOW') ||
            upperLine.includes('AUTHENTICATION BYPASS')) {
            return 'critical';
        }
        
        if (upperLine.includes('SQL INJECTION') || 
            upperLine.includes('XSS') ||
            upperLine.includes('PRIVILEGE ESCALATION')) {
            return 'high';
        }
        
        if (upperLine.includes('CVE-')) return 'medium';
        
        return 'info';
    }

    /**
     * Extract title from vulnerability line
     */
    extractTitleFromLine(line) {
        // Remove nmap formatting
        let title = line.replace(/^\|\s*/, '').trim();
        
        // Extract meaningful title
        if (title.includes(':')) {
            title = title.split(':')[0];
        }
        
        // Limit length
        if (title.length > 100) {
            title = title.substring(0, 97) + '...';
        }
        
        return title || 'Network Vulnerability';
    }

    /**
     * Clear all pending integrations
     */
    clearPendingIntegrations() {
        localStorage.removeItem('pendingNmapIntegrations');
    }

    /**
     * Get integration statistics
     */
    getIntegrationStats() {
        const pending = this.getPendingIntegrations();
        const all = JSON.parse(localStorage.getItem('pendingNmapIntegrations') || '[]');
        
        return {
            pending: pending.length,
            total: all.length,
            integrated: all.filter(item => item.integrated).length
        };
    }
}

// Create singleton instance
export const nmapIntegration = new NmapIntegrationUtility();

// Auto-initialize if vulnerability scanner is available
if (typeof window !== 'undefined') {
    window.addEventListener('load', () => {
        // Try to find vulnerability scanner app and initialize
        const checkForApp = () => {
            const container = document.querySelector('#vulnerability-scanner-container');
            if (container && container._vulnerabilityApp) {
                nmapIntegration.initialize(container._vulnerabilityApp);
                nmapIntegration.processPendingIntegrations();
                return true;
            }
            return false;
        };

        // Check immediately and then periodically
        if (!checkForApp()) {
            const interval = setInterval(() => {
                if (checkForApp()) {
                    clearInterval(interval);
                }
            }, 1000);
            
            // Stop checking after 30 seconds
            setTimeout(() => clearInterval(interval), 30000);
        }
    });
}
