# Web Target Registry Refactoring

This document describes the refactored structure of the web target registry system.

## Overview

The web target registry has been refactored from a monolithic file into a modular system with individual target files for better maintainability, extensibility, and organization.

## New Structure

```
targets/
├── index.js                           # Main targets index and registry
├── web-target-base.js                 # Base WebTarget class
└── municipality-voting/               # Municipality voting system targets
    ├── index.js                       # Municipality targets index
    ├── municipality-voting-group.js   # Target group configuration
    ├── vote-portal-target.js          # Voting portal target
    ├── vote-database-target.js        # Database server target
    ├── vote-admin-target.js           # Admin panel target
    └── vote-api-target.js             # API service target
```

## Key Components

### WebTarget Base Class (`web-target-base.js`)
- Contains the core WebTarget class with all methods
- Provides common functionality for all targets
- Includes vulnerability management, statistics, and utility methods

### Individual Target Files
Each target is now defined in its own file:
- **vote-portal-target.js**: Municipal voting portal configuration
- **vote-database-target.js**: Voting database server configuration  
- **vote-admin-target.js**: Election administration panel configuration
- **vote-api-target.js**: Voting API service configuration

Each target file exports:
- A factory function to create the target instance
- A configuration object with metadata

### Target Groups
- **municipality-voting-group.js**: Contains the MunicipalityVotingGroup class
- Manages all municipality voting system targets as a cohesive group
- Provides group-level statistics and filtering

### Registry System
- **web-target-registry.js**: Updated to use the modular system with direct imports
- Maintains backward compatibility with existing code
- Simplified initialization without complex async loading
- Provides synchronous access to all targets and groups

## Benefits

1. **Modularity**: Each target is self-contained and can be modified independently
2. **Extensibility**: Easy to add new target groups and individual targets
3. **Maintainability**: Smaller, focused files are easier to maintain
4. **Performance**: Direct imports provide fast, synchronous access
5. **Organization**: Clear separation of concerns and logical grouping
6. **Reliability**: Simplified architecture reduces complexity and potential issues

## Usage

### Adding a New Target

1. Create a new target file (e.g., `new-target.js`):
```javascript
import { WebTarget } from '../web-target-base.js';

export function createNewTarget() {
    return new WebTarget({
        id: 'new-target',
        name: 'New Target',
        url: 'https://example.com',
        // ... other properties
    });
}

export const newTargetConfig = {
    id: 'new-target',
    name: 'New Target',
    category: 'example',
    priority: 1
};
```

2. Add to the appropriate group index file
3. Update the main targets index if creating a new group

### Adding a New Target Group

1. Create a new directory for the group
2. Create individual target files in the directory
3. Create a group class file
4. Create an index file for the group
5. Update the main targets index to include the new group

## Backward Compatibility

The refactored system maintains full backward compatibility:
- All existing imports continue to work
- The `webTargetRegistry` singleton instance works as before
- All public methods remain unchanged
- Existing code requires no modifications

## Migration Path

For new development:
1. Use the modular target files when possible
2. Import specific targets from their individual files
3. Use target groups for batch operations
4. All target access is now synchronous and immediate

The old monolithic approach is still supported for existing code.
