/**
 * Scanner Logic Module for Vulnerability Scanner
 * Handles scan orchestration, state management, and callbacks
 */
export class VulnerabilityScannerLogic {
    constructor(vulnerabilityScanner, uiRenderer, dataManager, notificationManager, app = null) {
        this.scanner = vulnerabilityScanner;
        this.uiRenderer = uiRenderer;
        this.dataManager = dataManager;
        this.notificationManager = notificationManager;
        this.app = app; // Reference to the main vulnerability scanner app
        
        this.currentScan = null;
        this.isScanning = false;
        this.selectedTarget = null;
    }

    async startScan() {
        const selectedTargetId = this.uiRenderer.elements.targetSelect.value;
        if (!selectedTargetId) {
            this.notificationManager.show('Please select a target to scan', 'error');
            return;
        }

        const target = this.dataManager.getTarget(selectedTargetId);
        if (!target) {
            this.notificationManager.show('Selected target not found', 'error');
            return;
        }

        this.isScanning = true;
        this.uiRenderer.updateScanControls(this.isScanning);
        this.uiRenderer.showProgress();

        const scanOptions = this.getScanOptions();

        try {
            this.currentScan = await this.scanner.startScan(target.url, scanOptions, {
                onProgress: (progress) => {
                    this.handleProgress(progress);
                },
                onVulnerabilityFound: (vulnerability) => {
                    this.handleVulnerabilityFound(vulnerability, selectedTargetId);
                },
                onRequestMade: (request) => {
                    this.handleRequestMade(request);
                },
                onEvidenceCollected: (evidence) => {
                    this.handleEvidenceCollected(evidence);
                }
            });

            await this.currentScan.waitForCompletion();
            this.handleScanComplete();
            
        } catch (error) {
            this.handleScanError(error);
        }
    }

    stopScan() {
        if (this.currentScan) {
            this.currentScan.stop();
            this.currentScan = null;
        }
        this.isScanning = false;
        this.uiRenderer.updateScanControls(this.isScanning);
        this.uiRenderer.hideProgress();
        this.handleScanStopped();
    }

    getScanOptions() {
        const scanType = this.uiRenderer.elements.scanTypeSelect.value;
        
        if (scanType === 'custom') {
            return {
                sqlInjection: this.uiRenderer.elements.scanOptions.sqlInjection.checked,
                xss: this.uiRenderer.elements.scanOptions.xss.checked,
                directoryTraversal: this.uiRenderer.elements.scanOptions.directoryTraversal.checked,
                authenticationBypass: this.uiRenderer.elements.scanOptions.authenticationBypass.checked,
                csrf: this.uiRenderer.elements.scanOptions.csrf.checked
            };
        } else if (scanType === 'quick') {
            return {
                sqlInjection: true,
                xss: true,
                directoryTraversal: false,
                authenticationBypass: true,
                csrf: false
            };
        } else {
            // Comprehensive scan
            return {
                sqlInjection: true,
                xss: true,
                directoryTraversal: true,
                authenticationBypass: true,
                csrf: true
            };
        }
    }

    handleProgress(progress) {
        this.uiRenderer.updateProgress(progress);
    }

    handleVulnerabilityFound(vulnerability, targetId) {
        this.uiRenderer.addVulnerabilityToUI(vulnerability);
        this.uiRenderer.updateCounters();
        this.dataManager.addVulnerabilityToTarget(targetId, vulnerability);
        this.dataManager.updateStatistics();
    }

    handleRequestMade(request) {
        this.uiRenderer.addRequestToUI(request);
        this.uiRenderer.updateCounters();
    }

    handleEvidenceCollected(evidence) {
        this.uiRenderer.addEvidenceToUI(evidence);
        this.uiRenderer.updateCounters();
    }

    handleScanComplete() {
        this.isScanning = false;
        this.uiRenderer.updateScanControls(this.isScanning);
        this.uiRenderer.hideProgress();
        this.dataManager.updateStatistics();
        this.dataManager.updateTargetsList();
        this.notificationManager.show('Vulnerability scan completed successfully', 'success');
        
        // Trigger Level 4 ethical dilemmas if active
        if (this.app && this.app.level4DilemmaManager) {
            this.app.level4DilemmaManager.onScanCompleted();
        }
    }

    handleScanStopped() {
        this.notificationManager.show('Vulnerability scan stopped', 'warning');
    }

    handleScanError(error) {
        this.isScanning = false;
        this.uiRenderer.updateScanControls(this.isScanning);
        this.uiRenderer.hideProgress();
        this.notificationManager.show(`Scan failed: ${error.message}`, 'error');
    }

    exportResults() {
        if (!this.currentScan) {
            this.notificationManager.show('No scan results to export', 'warning');
            return;
        }

        const results = {
            timestamp: new Date().toISOString(),
            target: this.currentScan.target,
            vulnerabilities: this.currentScan.getVulnerabilities(),
            requests: this.currentScan.getRequests(),
            evidence: this.currentScan.getEvidence(),
            summary: this.currentScan.getSummary()
        };

        // Simulate file download
        const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `vuln_scan_results_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        this.notificationManager.show('Scan results exported successfully', 'success');
    }

    // Get current scan status
    getScanStatus() {
        return {
            isScanning: this.isScanning,
            currentScan: this.currentScan,
            selectedTarget: this.selectedTarget
        };
    }

    // Clean up scan state
    cleanup() {
        if (this.currentScan && this.isScanning) {
            this.currentScan.stop();
        }
        this.currentScan = null;
        this.isScanning = false;
        this.selectedTarget = null;
    }
}
